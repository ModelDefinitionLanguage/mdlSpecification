Tables <- gsub("\\.", "\\)", Tables, perl = T)
}
control2$Tables <- paste(Tables, collapse="\n")
## Ensure that multiple $EST case has $EST for each line
## First $Table statement doesn't need '$Table' since it comes from ctrlmerged if present
estBlockName <- paste("$",ctrlmerged$orig.block[ctrlmerged$RNMI.block=="Estimates"],sep="")
control2$Estimates <- paste(estBlockName, paste(control2$Estimates, collapse=paste("\n",estBlockName,sep="")))
control2$Problem <- paste(paste("$",ctrlmerged$orig.block[ctrlmerged$RNMI.block=="Problem"],sep=""), control2$Problem)
control2$Cov <- ifelse(grep("COV",ctrlmerged$orig.block)>0, "$COV\n",NULL)
simBlockName <- paste("$",ctrlmerged$orig.block[ctrlmerged$RNMI.block=="Sim"],sep="")
if(length(grep("^SIM",ctrlmerged$block.id))>0){
Seed1 <- ifelse(control2$Sim["Seed1"]>0, paste("(",control2$Sim["Seed1"],")", sep=""), "")
Seed2 <- ifelse(control2$Sim["Seed2"]>0, paste("(",control2$Sim["Seed2"],")", sep=""), "")
simOnly <- ifelse(control2$Sim["simOnly"], "ONLYSIMULATION", "")
subProb <- ifelse(control2$Sim["nSub"]==1,"",paste("SUBPROBLEMS=",control2$Sim["nSub"]))
true <- ifelse(control2$Sim["TRUE"]=="INITIAL", "", paste("TRUE=",control2$Sim["TRUE"]))
SIM <- paste(Seed1, Seed2, subProb, simOnly, true)
control2$Sim <- paste(simBlockName, SIM, collapse=" ")
}
control3 <- list(NULL)
for (i in 1:nrow(ctrlmerged)) {
if (ctrlmerged$block.id[i] %in% otherBlocks$block.id)
control3[[i]] <- control2[[ctrlmerged$RNMI.block[i]]]
if (ctrlmerged$block.id[i] %in% modelBlockNames)
control3[[i]] <- paste(modelBlockCode[[ctrlmerged$orig.block[i]]],collapse="")
names(control3)[[i]] <- ctrlmerged$orig.block[i]
}
control3
parsedControl2 <- parsedControl[[bb]]
firstLine <- probLines[bb]
lastLine <- ifelse(!is.na(probLines[bb+1]),(probLines[bb+1]-1),length(raw))
control <- raw[firstLine : lastLine]
### Where do the various block statements occur?
blockpos <- grep("^ *[$]", control)
blocks <- control[blockpos]
## Drop commented out lines blocks<-blocks[-grep('[;]',blocks)] Get first 'word' to
## determine order
blocks1 <- sub(" +.*", "", blocks)
blocks2 <- sub("$", "", blocks1, fixed = T)
orig1 <- data.frame(block = blocks2, line = blockpos, stringsAsFactors = F)
orig2 <- orig1[!duplicated(orig1$block), ]
blocks3 <- substr(orig2$block, 1, 3)
orig.pos <- c(1:length(blocks3))
orig <- data.frame(block.id = blocks3, orig.pos = orig.pos, orig.block = orig2$block, line = orig2$line,
stringsAsFactors = F)
### Get list of objects from the parsed Control file
control2 <- parsedControl2
control2BlockNames <-  casefold( names( control2 ), upper = T )
control2Blocks <- substr(control2BlockNames, 1, 3 )
### Handling case where the original block is $THTA or $THT
control2Blocks[names(control2)=="Theta"] <- orig[grep("\\$TH(E){0,1}TA", blocks1), "block.id"]
RNMI.pos <- c(1:length(control2Blocks))
RNMI <- data.frame(block.id = control2Blocks, RNMI.pos = RNMI.pos, RNMI.block = names(parsedControl2),
stringsAsFactors = F)
## Match blocks in control file to items in the parsed list
ctrlmerged <- merge(orig, RNMI, by = "block.id", all = T)
ctrlmerged <- ctrlmerged[order(ctrlmerged$orig.pos), ]
ctrlmerged$orig.block[ is.na( ctrlmerged$orig.block ) ] <- casefold(ctrlmerged$RNMI.block[ is.na( ctrlmerged$orig.block ) ], upper = T)
## Leave out model related blocks from parsedControl2 Will pick these up directly from Raw
## file.  This means that we do not expect user to update the model!
otherBlocks <- ctrlmerged[!(ctrlmerged$block.id %in% modelBlockNames), ]
control2 <- control2[otherBlocks$RNMI.block]
## If blocks appear in the original, but not RNMImport parsed version then create RNMImport
## blocks.  e.g. $DES
modelBlockCode <- list(NULL)
modelBlocks <- ctrlmerged[ctrlmerged$block.id %in% modelBlockNames, ]
if(nrow(modelBlocks)>0){
for (i in 1:nrow(modelBlocks)) {
nextBlock <- ctrlmerged[modelBlocks$orig.pos[i] + 1, ]
modelStart <- modelBlocks$line[i]
modelEnd <- nextBlock$line - 1
codeLines <- control[modelStart:modelEnd]
codeLines <- paste(codeLines, "\n")
## Last line doesn't need the line break
codeLines[length(codeLines)] <- sub("\\n","",codeLines[length(codeLines)])
modelBlockCode[[i]] <- codeLines
names(modelBlockCode)[[i]] <- modelBlocks$orig.block[i]
}
addBlocks <- list(NULL)
missBlocks <- ctrlmerged[is.na(ctrlmerged$RNMI.pos) & !(ctrlmerged$block.id %in% modelBlockNames),]
if (nrow(missBlocks) > 0) {
for (i in 1:nrow(missBlocks)) {
nextBlock <- ctrlmerged[missBlocks$orig.pos[i] + 1, ]
missStart <- missBlocks$line[i] + 1  ## NOTE! The +1 here might cause trouble!
missEnd <- nextBlock$line - 1
codeLines <- control[missStart:missEnd]
addBlocks[[i]] <- codeLines
names(addBlocks)[[i]] <- as.character(missBlocks$block.id[i])
newRNMIpos <- max(ctrlmerged$RNMI.pos, na.rm = T) + i
ctrlmerged[ctrlmerged$block.id == missBlocks[i, "block.id"], "RNMI.pos"] <- newRNMIpos
}
#########################################################
###
###   THETA
###
#########################################################
Theta.txt <- NULL
## Defensive programming to handle case where there are no THETA records.
## RNMImport doesn't handle this well yet
if(!grep("NA",control2$Theta[1])>0){
### Change $THETA -Inf and Inf values to missing Change $THETA values = 0 to '0 FIX'
Theta <- formatC(as.matrix(control2$Theta[,c("Lower","Est","Upper")]))
Theta <- apply(Theta, 2, function(x) sub("^ *Inf", NA, x))
Theta <- apply(Theta, 2, function(x) sub("^ *-Inf", NA, x))
## If initial value is zero then it must be fixed. NONMEM initial values cannot be zero.
# control2$Theta[Theta[, 2] == 0, "FIX"] <- TRUE
## Prepare for printing out
## Combine $THETA bounds into usual NONMEM format e.g. (0, 0.5, ) OR 0.5 OR (,0.5,1000)
for (i in 1 : nrow(Theta) ){
## Handle FIXED Thetas
if (control2$Theta[i,"FIX"]){
Theta.txt[i] <- paste(Theta[i,2],"FIX")
} else {
## Handle THETAs where only a single value is given for inits
if ( is.na( Theta[i,1] ) & is.na( Theta[i,3] ) ){
Theta.txt[i] <- Theta[i, 2]
} else {
## Else create lower and/or upper bounded THETAs
Theta.txt[i] <- paste("(", paste(Theta[i,], collapse = ","), ")")
Theta.txt[i] <- gsub("NA", "", Theta.txt[i])
}
Theta.txt <- paste(Theta.txt, ";", control2$Theta[,"comments"])
thetaBlockName <- paste("$",ctrlmerged$orig.block[ctrlmerged$RNMI.block=="Theta"],sep="")
control2$Theta <- paste(paste(thetaBlockName,"\n",sep=""),paste(Theta.txt, collapse="\n"))
#########################################################
###
###   OMEGA
###
#########################################################
Omega.txt <- NULL
if(!is.null(control2$Omega)){
control2$Omega$initialMatrix <- NULL
for (i in 1:length( control2$Omega ) ){
x <- control2$Omega[[i]]
if ( !is.null( x$block ) ){
## Print BLOCK(n)
## If SAME then don't print values just text
x$block <- paste( paste("$OMEGA BLOCK(", x$block, ")", sep=""),if( x$SAME) "SAME","\n")
if (!x$SAME){
x$values[upper.tri(x$values)] <- ""
x$values <- as.data.frame(x$values)
x$values <- ifelse(!x$SAME,paste( apply( x$values, 1, paste, collapse=" "), collapse = "\n" ), NULL)
}
if (x$SAME) { x$values <- ""}
## If FIX then add this
x$FIX <- ifelse( x$FIX , "FIX \n" , "\n")
Omega.txt[[i]] <- paste0(list(x$block, x$values, x$FIX),collapse="")
} else {
y <- data.frame(x)
y$FIX <- ifelse(x$FIX, "FIX", "")
y$comments <- ifelse( !is.na(x$comments), paste(";",x$comments), "" )
out <- apply(y, 1, paste, collapse=" ")
omegaBlockName <-  paste("$",ctrlmerged$orig.block[ctrlmerged$RNMI.block=="Omega"],sep="")
Omega.txt[[i]] <- paste(paste(omegaBlockName,"\n",sep=""),paste(out,collapse=" \n"))
}
Omega.txt <- paste( Omega.txt, collapse = "" )
}
## Overwrite control2$Omega with Omega above.
control2$Omega <- Omega.txt
#########################################################
###
###   SIGMA
###
#########################################################
Sigma.txt <- NULL
if(!is.null(control2$Sigma)){
control2$Sigma$initialMatrix <- NULL
for (i in 1:length( control2$Sigma ) ){
x <- control2$Sigma[[i]]
if ( !is.null( x$block ) ){
## Print BLOCK(n)
## If SAME then don't print values just text
x$block <- paste( paste("$SIGMA BLOCK(", x$block, ")", sep=""),if( x$SAME) "SAME","\n")
if (!x$SAME){
x$values[upper.tri(x$values)] <- ""
x$values <- as.data.frame(x$values)
x$values <- ifelse(!x$SAME,paste( apply( x$values, 1, paste, collapse=" "), collapse = "\n" ), NULL)
}
if (x$SAME) { x$values <- ""}
## If FIX then add this
x$FIX <- ifelse( x$FIX , "FIX \n" , "\n")
Sigma.txt[[i]] <- paste0(list(x$block, x$values, x$fixed),collapse="")
} else {
y <- data.frame(x)
y$FIX <- ifelse(x$FIX, "FIX", "")
y$comments <- ifelse( !is.na(y$comments), paste(";",y$comments), "")
out <- apply(y, 1, paste, collapse=" ")
sigmaBlockName <-  paste("$",ctrlmerged$orig.block[ctrlmerged$RNMI.block=="Sigma"],sep="")
Sigma.txt[[i]] <- paste(paste(sigmaBlockName,"\n",sep=""), paste(out,collapse=" \n"))
}
Sigma.txt <- paste( Sigma.txt, collapse = "" )
}
control2$Sigma <- Sigma.txt
Input <- control2$Input[, "nmName"]
Input
ctrlmerged$orig.block[ctrlmerged$RNMI.block=="Input"]
ctrlmerged$RNMI.block=="Input"
ctrlmerged
grep("Theta",ctrlmerged$RNMI.block)
ctrlmerged$RNMI.block
grep("Theta",ctrlmerged$RNMI.block)
RNMI.block[grep("Theta",ctrlmerged$RNMI.block)]
ctrlmerged$RNMI.block[grep("Theta",ctrlmerged$RNMI.block)]
as.character(ctrlmerged$RNMI.block[grep("Theta",ctrlmerged$RNMI.block)])
thetaBlockName <- ifelse(length(grep("Theta",ctrlmerged$RNMI.block))>0,
ctrlmerged$RNMI.block[grep("Theta",ctrlmerged$RNMI.block)],
"")
thetaBlockName
set.seed(123)
round(runif(10,0,10),0)
q()
set.seed(123)
round(runif(10,0,10),0)
?which
library(sparql)
library(SPARQL)
install.packages(SPARQL)
?install.packages
install.packages(SPARQL, repos="http://cran.us.r-project.org")
install.packages("SPARQL", repos="http://cran.us.r-project.org")
library(SPARQL) # SPARQL querying package
library(ggplot2)
endpoint <- "http://services.data.gov/sparql"
query <-
"PREFIX  dgp1187: <http://data-gov.tw.rpi.edu/vocab/p/1187/>
SELECT ?ye ?fi ?ac
WHERE {
?s dgp1187:year ?ye .
?s dgp1187:fires ?fi .
?s dgp1187:acres ?ac .
}"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint,query)
df <- qd$results
d <- SPARQL(url="http://services.data.gov.uk/reference/sparql",
query="SELECT * WHERE { ?s ?p ?o . } LIMIT 10",
ns=c('time','<http://www.w3.org/2006/time#>'))
is.data.frame(d$results)
head(d)
endpoint <- "http://semanticweb.cs.vu.nl/lop/sparql/"
q <-
"SELECT *
WHERE {
?event sem:hasPlace ?place .
?place eez:inPiracyRegion ?region .
} LIMIT 20"
prefix <-
c(
"lop",
"http://semanticweb.cs.vu.nl/poseidon/ns/instances/",
"eez",
"http://semanticweb.cs.vu.nl/poseidon/ns/eez/"
)
res <- SPARQL(endpoint, q, prefix)$results
pie(sort(table(res$region)), col = rainbow(12))
endpoint <- "http://semanticweb.cs.vu.nl/lop/sparql/"
q <-
"SELECT *
WHERE {
?event sem:hasPlace ?place .
?place eez:inPiracyRegion ?region .
}"
prefix <- c("lop","http://semanticweb.cs.vu.nl/poseidon/ns/instances/",
"eez","http://semanticweb.cs.vu.nl/poseidon/ns/eez/")
res <- SPARQL(endpoint,q,prefix)$results
pie(sort(table(res$region)),col=rainbow(12))
q <-
"SELECT *
WHERE {
?event sem:eventType ?event_type .
?event sem:hasPlace ?place .
?place eez:inPiracyRegion ?region .
}"
res <- SPARQL(endpoint,q,ns=prefix)$results
restable <- table(res$event_type,res$region)
par(mar=c(4,10,1,1))
barplot(restable,col=rainbow(10),horiz=TRUE,las=1,cex.names=0.8)
legend("topright",rownames(restable),
cex=0.8,bty="n",fill=rainbow(10))
endpoint <- "http://services.data.gov/sparql"
query <-
"PREFIX  dgp1187: <http://data-gov.tw.rpi.edu/vocab/p/1187/>
SELECT ?ye ?fi ?ac
WHERE {
?s dgp1187:year ?ye .
?s dgp1187:fires ?fi .
?s dgp1187:acres ?ac .
}"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint,query)
df <- qd$results
endpoint <- "http://services.data.gov/sparql"
# create query statement
query <-
"PREFIX  D961: <http://data-gov.tw.rpi.edu/vocab/Dataset_961>
SELECT ?ye ?fi ?ac
WHERE {
?s .
?p .
?o .
}"
qd <- SPARQL(endpoint,query)
endpoint <- "hhttp://demo.openlinksw.com/sparql"
# create query statement
query <-
" PREFIX foaf:  <http://xmlns.com/foaf/0.1/>
SELECT ?name
WHERE {
?person foaf:name ?name .
}"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint, query)
df <- qd$results
endpoint <- "http://demo.openlinksw.com/sparql"
# create query statement
query <-
" PREFIX foaf:  <http://xmlns.com/foaf/0.1/>
SELECT ?name
WHERE {
?person foaf:name ?name .
}"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint, query)
df <- qd$results
head(df)
dim(df)
df[1,1:10]
query <-
"SELECT ?p ?o
{
<http://nasa.dataincubator.org/spacecraft/1968-089A> ?p ?o
}"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint, query)
df <- qd$results
df
qd
query <-
"PREFIX space: <http://purl.org/net/schemas/space/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
SELECT ?disc ?label
{
<http://nasa.dataincubator.org/spacecraft/1968-089A> space:discipline ?disc .
?disc rdfs:label ?label
}"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint, query)
df <- qd$results
head(df)
qd
endpoint <- "http://api.talis.com/stores/space/items/tutorial/spared.html"
# create query statement
query <-
"PREFIX space: <http://purl.org/net/schemas/space/>
SELECT ?craft
{
?craft a space:Spacecraft
}
LIMIT 50"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint, query)
df <- qd$results
query <-
"PREFIX space: <http://purl.org/net/schemas/space/>
SELECT ?craft
{
?craft a space:Spacecraft
}
LIMIT 50"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint, query)
df <- qd$results
endpoint <- "http://api.talis.com/stores/space/items/tutorial/spared.html"
# create query statement
query <-
"PREFIX space: <http://purl.org/net/schemas/space/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT *
{ ?launch space:launched ?date
FILTER (
?date > "1968-10-1"^^xsd:date &&
?date < "1968-10-30"^^xsd:date
)
}"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint, query)
df <- qd$results
endpoint <- "http://dbtune.org/jamendo/store/user/query"
# create query statement
query <-
"PREFIX mo: <http://purl.org/ontology/mo/>
PREFIX foaf:  <http://xmlns.com/foaf/0.1/>
SELECT ?name ?img ?hp ?loc
WHERE {
?a a mo:MusicArtist ;
foaf:name ?name ;
foaf:img ?img ;
foaf:homepage ?hp ;
foaf:based_near ?loc .
}
"
# Step 2 - Use SPARQL package to submit query and save results to a data frame
qd <- SPARQL(endpoint, query)
df <- qd$results
library(rrdf)
install.packages("rrdf")
.libPaths()
devtools::install_github("egonw/rrdf", subdir="rrdflibs")
devtools::install_github("egonw/rrdf", subdir="rrdf", build_vignettes = FALSE)
install.packages("rJava")
devtools::install_github("egonw/rrdf", subdir="rrdflibs")
.libPaths()
install.packages("rrdf")
library(rrdf)
q()
library(rrdf)
devtools::install_github(repo = "rrdf", username = "egonw")
devtools::install_github(repo = "egonw/rrdf")
devtools::install_github(repo = "egonw/rrdflibs")
install.packages("rJava")
install_github("egonw/rrdf", subdir="rrdflibs")
devtools::install_github("egonw/rrdf", subdir="rrdflibs")
devtools::install_github("egonw/rrdf", subdir="rrdf", build_vignettes = FALSE)
devtools::install_github("egonw/rrdf", subdir="rrdflibs", build_vignettes = FALSE)
library("rJava", lib.loc="~/R/win-library/3.2")
library("SPARQL", lib.loc="~/R/win-library/3.2")
library("tibble", lib.loc="~/R/win-library/3.2")
remove.packages("rJava", lib="~/R/win-library/3.2")
remove.packages("SPARQL", lib="~/R/win-library/3.2")
remove.packages("tibble", lib="~/R/win-library/3.2")
updatePfizerPackages()
checkPfizerPackages()
View(checkPfizerPackages)
.libPaths()
install.packages("tibble",.libPaths()[1])
install.packages("tibble", .libPaths()[1])
pfizerPackages.defaultVersion <- paste(R.version["major"], R.version["minor"], sep=".")
pfizerPackages.defaulturl <- paste("file://ndhnas500vfs08/rwincran/R-", pfizerPackages.defaultVersion, "/CRAN",sep="")
pfizerPackages.defaultInstall <- paste(.libPaths()[1],"/",sep="")
checkPfizerPackages()
checkPfizerPackages(contriburl = pfizerPackages.defaulturl)
library(rJava)
system("java -version")
system("java -d64version")
system("java -d64 -version")
library(rJava)
devtools::install_github("egonw/rrdf", subdir="rrdflibs")
devtools::install_github("egonw/rrdf", subdir="rrdf", build_vignettes = FALSE)
library(rrdf)
endpoint = "http://rdf.farmbio.uu.se/chembl/sparql"
query = "
SELECT ?organism ?instance
WHERE {
?instance a <http://rdf.farmbio.uu.se/chembl/onto/#Target> ;
<http://rdf.farmbio.uu.se/chembl/onto/#organism> ?organism .
}
";
data = sparql.remote(endpoint, query)
head(data)
endpoint = "git://git.code.sf.net/p/tfserverref/code"
query = "
CONSTRUCT {?s ?o ?p .}
WHERE {
#GET THE ACTIVITY
{
?s  ?o ?p .
FILTER(?s in (<actvitystring>))
}
#GET THE SUB ACTVITY OPEJECTS
UNION
{
?y  ?o1 ?p1 .
FILTER(?y in (<actvitystring>))
?y  ?o2 ?s .
?s ?o ?p
FILTER (!isBlank(?p))
}
# RELATED TO
UNION
{
?s  ?o ?p .
FILTER(?p in (<actvitystring>))
}
UNION
{
?s  ?o1 ?p1 .
FILTER(?p1 in (<actvitystring>))
?s ?o ?p .
}
";
data = sparql.remote(endpoint, query)
getwd()
?create
??create
library(PopED)
library("PopED", lib.loc="C:/Program Files/R/R-3.2.2/library")
update.packages()
update.packages(ask = F)
library(rmarkdown)
library(poped)
library(PopED)
install.packages("poped")
install.packages("PopED")
citation("PopED")
install.packages("RxODE")
citation("RxODE")
citation("mrgsolve")
citation("PKPDsim")
bookdown::serve_book()
blogdown::build_site()
setwd("~/Working documents/MDLWebsite")
blogdown::build_site()
